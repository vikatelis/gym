import math
import random

import gym
from gym import spaces
import gym.spaces
from gym.utils import seeding
import numpy as np
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import (RBF, Matern, RationalQuadratic,
                                              ExpSineSquared, DotProduct,
                                              ConstantKernel)
from scipy import interpolate

class GP(gym.Env):
    def __init__(self):
        # define dimensionality
        self.ndim = 2
        # kernels
        # 1.0 * ExpSineSquared(length_scale=1.0, periodicity=3.0,
        #                length_scale_bounds=(0.1, 10.0),
        #                periodicity_bounds=(1.0, 10.0)),
        self.kernels = [1.0 * RBF(length_scale=8.0, length_scale_bounds=(1e-1, 10.0)),
                        1.0 * RationalQuadratic(length_scale=1.0, alpha=0.1),
                        ConstantKernel(0.1, (0.01, 10.0))
                            * (DotProduct(sigma_0=1.0, sigma_0_bounds=(0.1, 10.0)) ** 2),
                        1.0 * Matern(length_scale=1.0, length_scale_bounds=(1e-1, 10.0),
                                nu=1.5)]
        # range action
        self.min_action = -10*np.ones(self.ndim)
        self.max_action = 10*np.ones(self.ndim)
        # range observation - dimensionality
        self.low_state = np.append([-30.0, -30.0],self.min_action)
        self.high_state = np.append([30.0,30.0],self.max_action)
        # range state - dimensionality
        self.low_state_p = -6*np.ones(self.ndim)
        self.high_state_p = 6*np.ones(self.ndim)
        # meshgrid of states
        #self.x_ = np.arange(self.low_state_p[0]-1,self.high_state_p[0]+1,1)
        self.x_ = np.arange(-8,8,1)
        self.grid = np.array(np.meshgrid(self.x_, self.x_)).T.reshape(-1,2)
        print(self.grid.shape)
        #self.grid = self.grid.reshape(-1,1)
        #print(self.grid.shape)
        # boxes
        self.action_space = spaces.Box(low=self.min_action, high=self.max_action)
        self.observation_space = spaces.Box(low=self.low_state, high=self.high_state)
        self.hyper_space = spaces.Box(low=self.low_state_p, high=self.high_state_p)
        # init
        self.obs = self.observation_space.sample()
        self.state = self.hyper_space.sample()
        self.prev_unscaled = 0
        self.gp = 0

        # init thread
        self.seed()
        self.reset()

    def step(self, action):
        """ Step in gym env """
        loss = self.gp_step(action)
        # rewarding - try it unscaled
        reward = np.asscalar(float(self.prev_unscaled - loss)/(self.prev_unscaled + 1.0e-5))
        self.count = self.count + 1
        if not (self.hyper_space.contains(self.state)):
            # exited box
            reward = min(2*reward,-10)
            done = True
        else:
            done = False
        self.prev_loss = loss
        return self.obs, reward, done, {}

    def gp_step(self,action):
        """ Step in GP function """
        self.state += action
        ## state description update
        f_ = self.gp_eval();
        self.get_observation(f_, action)
        return f_

    def gp_eval(self):
        """ Evaluate function generated by self.gp """
        test = self.state.reshape(1, -1)
        # get covariance of prev state and current state
        #y_samples = self.gp.sample_y(test)
        y_samples = self.loss_func(self.state[0],self.state[1])
        #y_samples = self.gp.sample_y(test,1, None)
        return y_samples

    def get_observation(self, curr_loss, step):
        """ Transform state in invariant observation -- TO DO: invariance?? """
        #print("ddd ",str(self.prev_unscaled - curr_loss))
        test = self.prev_unscaled - curr_loss
        self.obs = np.append([self.prev_unscaled - curr_loss, curr_loss], step)
        # reassign the prev_loss
        self.prev_unscaled = curr_loss
        return

    def scale(self,f_):
        """ Scaling -- TO DO: need for invariant scaling """
        return 30*f_ /(30+abs(f_))

    def seed(self, seed=None):
        """ Seed """
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def reset(self):
        """ Reset Gym Env """
        self.gp = 0
        self.loss_func = 0
        self.count = 0
        # choose kernel randomly
        kernel_ind = random.randint(0,len(self.kernels)-1)
        kernel = self.kernels[kernel_ind]
        # Generate function with Gaussian Process
        self.gp = GaussianProcessRegressor(kernel=kernel)
        # calculate current prior and interpolate between points
        z = self.gp.sample_y(self.grid, n_samples=1, random_state=None)
        #self.loss_func = interpolate.interp2d(self.grid[:,0], self.grid[:,1], z, kind='cubic')
        #self.loss_func = interpolate.RectBivariateSpline(self.grid[:,0], self.grid[:,1], z)
        self.loss_func = interpolate.Rbf(self.grid[:,0], self.grid[:,1], z)
        #print("2")
        # init position and shape
        self.state = self.hyper_space.sample()
        # init observation _ need steps to initialize
        self.step(np.zeros(self.ndim))
        f_ = self.gp_eval()
        # step 0.1
        self.step(0.1*np.ones(self.ndim))
        # TODO: RETURN self ons and not self.state ??
        #  reset counter
        self.count = 0
        return self.obs
        #return np.array(self.state)
